<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4285f4">
    <meta name="description" content="A simple Progressive Web App template">
    <title>Speech to Braille Refreshable Module</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="images/icons/icon-192x192.png">
</head>
<body>
    <header>
        <h1>Speech to Braille Refreshable Module</h1>
    </header>
    
    <main>
        <div id="connection-status" class="status">
            Checking connection...
        </div>
        
        <button id="install-button" class="install-button">Install App</button>
        
        <div class="card">
            <h2>Welcome to your PWA</h2>
            <p>This Progressive Web App template is designed to work offline on mobile devices. It includes:</p>
            <ul>
                <li>Service worker for offline caching</li>
                <li>Web App Manifest for installation</li>
                <li>Responsive design</li>
                <li>Network status detection</li>
            </ul>
        </div>
        
        <div class="card">
            <h2>Cached Content</h2>
            <p>This content will be available even when you're offline.</p>
            <p>Last updated: <span id="last-updated">Loading...</span></p>
        </div>
        
        <div class="card">
            <h2>Speech Recognition</h2>
            <p>Speak into your microphone and see the text appear in real-time.</p>
            <div id="speech-controls">
                <button id="start-speech-btn">Start Speaking</button>
                <button id="stop-speech-btn" disabled>Stop</button>
                
                <!-- New selection for speech recognition method -->
                <div class="speech-method-selector">
                    <label for="speech-method">Recognition Method:</label>
                    <select id="speech-method">
                        <option value="webspeech">Web Speech API</option>
                        <option value="local">Local Recognition</option>
                    </select>
                </div>
                
                <button id="load-model-btn">Load Local Model</button>
                <div id="recording-indicator" class="recording-off">● Recording</div>
            </div>
            
            <!-- Add loading progress bar -->
            <div id="loading-container" class="loading-container">
                <div class="progress-bar">
                    <div id="progress-bar" class="progress progress-striped"></div>
                </div>
                <div id="progress-status" class="progress-status">Preparing to download model...</div>
            </div>
            
            <div id="model-status">
                Recognition Model: <span class="model-badge no-model" id="model-badge">Not Selected</span>
            </div>
            <div id="speech-output">
                <p id="interim-text"></p>
                <p id="final-text"></p>
            </div>
        </div>
        
        <!-- New Braille Translator Card -->
        <div class="card">
            <h2>Braille Translation</h2>
            <p>Matches from your speech are converted to Braille:</p>
            
            <div id="braille-status" class="status">
                Loading Braille database...
            </div>
            
            <div id="braille-result" class="braille-result hidden">
                <div class="braille-match-info">
                    <h3>Matched Word: <span id="matched-word">None</span></h3>
                    <p>Language: <span id="braille-language">N/A</span></p>
                </div>
                <div class="braille-display">
                    <div class="braille-symbol-container">
                        <h4>Braille Symbol:</h4>
                        <div id="braille-symbol" class="braille-symbol">⠿</div>
                    </div>
                    <div class="braille-array-container">
                        <h4>Braille Array:</h4>
                        <pre id="braille-array" class="braille-array">[1,2,3,4,5,6]</pre>
                    </div>
                </div>
            </div>
            
            <div id="no-match-info" class="braille-no-match hidden">
                <p>No matching words found in the current sentence.</p>
                <p>Try speaking a different phrase containing words from the Braille database.</p>
            </div>
        </div>
        
        <div class="card">
            <h2>Dynamic Content</h2>
            <p>This section displays the cached resources in this application:</p>
            <button id="refresh-button">Check Cache Status</button>
            <div id="dynamic-content">
                <p>Loading cache information...</p>
            </div>
        </div>
    </main>
    
    <footer>
        <p>Progressive Web App Template &copy; 2025</p>
    </footer>

    <!-- Import our custom speech recognition implementation -->
    <script src="js/alternatives/speech-recognition.js"></script>
    
    <!-- Import our Braille translator module -->
    <script src="js/braille-translator.js"></script>
    
    <script>
        // Speech recognition functionality
        let recognitionActive = false;
        
        // DOM elements
        const startSpeechBtn = document.getElementById('start-speech-btn');
        const stopSpeechBtn = document.getElementById('stop-speech-btn');
        const loadModelBtn = document.getElementById('load-model-btn');
        const speechMethodSelect = document.getElementById('speech-method');
        const recordingIndicator = document.getElementById('recording-indicator');
        const interimTextElement = document.getElementById('interim-text');
        const finalTextElement = document.getElementById('final-text');
        const modelBadge = document.getElementById('model-badge');
        const loadingContainer = document.getElementById('loading-container');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        
        // Braille translation elements
        const brailleStatus = document.getElementById('braille-status');
        const brailleResult = document.getElementById('braille-result');
        const matchedWordElement = document.getElementById('matched-word');
        const brailleLanguageElement = document.getElementById('braille-language');
        const brailleSymbolElement = document.getElementById('braille-symbol');
        const brailleArrayElement = document.getElementById('braille-array');
        const noMatchInfo = document.getElementById('no-match-info');
        
        // Remove any old buttons that were added programmatically
        const oldButtons = document.querySelectorAll('main > button');
        oldButtons.forEach(button => {
            if (button.textContent === 'Start Speech Recognition' || 
                button.textContent === 'Load Speech Recognition Model') {
                button.remove();
            }
        });
        
        // Helper function to update progress bar
        function updateLoadingProgress(percent, statusText) {
            progressBar.style.width = `${percent}%`;
            if (statusText) {
                progressStatus.textContent = statusText;
            }
        }
        
        // Check if speech recognition is defined before using it
        if (typeof speechRecognition === 'undefined') {
            console.error('Speech recognition module is not loaded');
            alert('Speech recognition module is not available. Please check console for errors.');
        }
        
        // Set initial state based on Web Speech API availability
        document.addEventListener('DOMContentLoaded', async function() {
            if (typeof speechRecognition !== 'undefined' && speechRecognition.isSupported()) {
                if (speechRecognition.webSpeechRecognition) {
                    updateModelStatus('webspeech');
                    modelBadge.textContent = 'Web Speech API Available';
                    loadModelBtn.textContent = 'Load Local Model';
                    startSpeechBtn.disabled = false;
                } else {
                    updateModelStatus('none');
                    modelBadge.textContent = 'No Recognition Available';
                    loadModelBtn.textContent = 'Load Local Model';
                    startSpeechBtn.disabled = true;
                }
            } else {
                updateModelStatus('none');
                modelBadge.textContent = 'Not Available';
                loadModelBtn.disabled = true;
                startSpeechBtn.disabled = true;
                console.error('Speech recognition is not supported');
            }
            
            // Initialize Braille translator
            if (typeof brailleTranslator !== 'undefined') {
                brailleStatus.textContent = 'Loading Braille database...';
                brailleStatus.className = 'status';
                
                // Add retry button for manual database loading
                const retryButton = document.createElement('button');
                retryButton.textContent = 'Retry Loading Database';
                retryButton.id = 'retry-braille-db-btn';
                retryButton.style.marginTop = '10px';
                retryButton.style.display = 'none';
                brailleStatus.appendChild(document.createElement('br'));
                brailleStatus.appendChild(retryButton);
                
                // Add event listener to retry button
                retryButton.addEventListener('click', async () => {
                    brailleStatus.textContent = 'Retrying database load...';
                    brailleStatus.className = 'status';
                    retryButton.style.display = 'none';
                    brailleStatus.appendChild(document.createElement('br'));
                    brailleStatus.appendChild(retryButton);
                    
                    try {
                        const success = await brailleTranslator.init();
                        if (success) {
                            const dbSize = brailleTranslator.getDatabaseSize();
                            brailleStatus.textContent = `Braille database loaded with ${dbSize} entries`;
                            brailleStatus.className = 'status online';
                            retryButton.style.display = 'none';
                        } else {
                            brailleStatus.textContent = 'Failed to load Braille database';
                            brailleStatus.className = 'status offline';
                            retryButton.style.display = 'inline-block';
                            showDatabaseDebugInfo();
                        }
                    } catch (error) {
                        console.error('Error initializing Braille translator:', error);
                        brailleStatus.textContent = `Error loading database: ${error.message}`;
                        brailleStatus.className = 'status offline';
                        retryButton.style.display = 'inline-block';
                        showDatabaseDebugInfo();
                    }
                });
                
                // Function to display database debug info
                function showDatabaseDebugInfo() {
                    // Check if the CSV file exists and display diagnostic information
                    const debugDiv = document.createElement('div');
                    debugDiv.className = 'database-debug-info';
                    debugDiv.style.marginTop = '10px';
                    debugDiv.style.padding = '10px';
                    debugDiv.style.backgroundColor = '#f8f9fa';
                    debugDiv.style.border = '1px solid #dee2e6';
                    debugDiv.style.borderRadius = '4px';
                    
                    const debugTitle = document.createElement('h4');
                    debugTitle.textContent = 'Diagnostic Information';
                    debugTitle.style.margin = '0 0 10px 0';
                    debugDiv.appendChild(debugTitle);
                    
                    // Check file availability
                    fetch('/ueb-philb-braille-database.csv', { 
                        method: 'HEAD',
                        cache: 'no-store'
                    })
                    .then(response => {
                        const fileInfo = document.createElement('p');
                        if (response.ok) {
                            fileInfo.textContent = '✅ Database file is accessible via direct path';
                            fileInfo.style.color = '#155724';
                        } else {
                            fileInfo.textContent = '❌ Database file is not accessible via direct path';
                            fileInfo.style.color = '#721c24';
                        }
                        debugDiv.appendChild(fileInfo);
                        
                        // Add server information
                        const serverInfo = document.createElement('p');
                        serverInfo.textContent = `Server base URL: ${window.location.origin}`;
                        debugDiv.appendChild(serverInfo);
                        
                        // Add helpful suggestions
                        const suggestions = document.createElement('ul');
                        suggestions.innerHTML = `
                            <li>Make sure the file "ueb-philb-braille-database.csv" exists in the root directory</li>
                            <li>Check if the file permissions allow it to be read</li>
                            <li>Try refreshing the page with Ctrl+F5 to clear cache</li>
                            <li>Check the browser console for additional error details</li>
                        `;
                        debugDiv.appendChild(suggestions);
                    })
                    .catch(error => {
                        const errorInfo = document.createElement('p');
                        errorInfo.textContent = `Error checking file: ${error.message}`;
                        errorInfo.style.color = '#721c24';
                        debugDiv.appendChild(errorInfo);
                    })
                    .finally(() => {
                        brailleStatus.appendChild(debugDiv);
                    });
                }
                
                try {
                    const success = await brailleTranslator.init();
                    if (success) {
                        const dbSize = brailleTranslator.getDatabaseSize();
                        brailleStatus.textContent = `Braille database loaded with ${dbSize} entries`;
                        brailleStatus.className = 'status online';
                    } else {
                        brailleStatus.textContent = 'Failed to load Braille database';
                        brailleStatus.className = 'status offline';
                        retryButton.style.display = 'inline-block';
                        showDatabaseDebugInfo();
                    }
                } catch (error) {
                    console.error('Error initializing Braille translator:', error);
                    brailleStatus.textContent = `Error loading database: ${error.message}`;
                    brailleStatus.className = 'status offline';
                    retryButton.style.display = 'inline-block';
                    showDatabaseDebugInfo();
                }
            } else {
                console.error('Braille translator module is not loaded');
                brailleStatus.textContent = 'Braille translator not available';
                brailleStatus.className = 'status offline';
            }
        });
        
        // Load model button setup
        loadModelBtn.addEventListener('click', async () => {
            loadModelBtn.disabled = true;
            loadModelBtn.textContent = 'Loading Model...';
            
            // Show loading bar
            loadingContainer.style.display = 'block';
            updateLoadingProgress(0, 'Preparing to download model...');
            
            try {
                // Load local model for speech recognition
                await speechRecognition.loadLocalModel({
                    progressCallback: updateLoadingProgress
                });
                
                // Update button state
                loadModelBtn.textContent = 'Model Loaded';
                loadModelBtn.style.backgroundColor = '#4CAF50'; // Green color for success
                updateModelStatus('local');
                startSpeechBtn.disabled = false;
                
                // Complete the progress bar and hide after a delay
                updateLoadingProgress(100, 'Model loaded successfully!');
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('Error loading local model:', error);
                loadModelBtn.textContent = 'Load Local Model';
                loadModelBtn.disabled = false;
                updateModelStatus('none');
                
                // Show error in progress bar
                updateLoadingProgress(100, `Error: ${error.message}`);
                progressBar.style.backgroundColor = '#ea4335'; // Red for error
                
                setTimeout(() => {
                    loadingContainer.style.display = 'none';
                    progressBar.style.backgroundColor = '#4285f4'; // Reset color
                }, 5000);
                
                alert('Failed to load the speech recognition model. Please try the Web Speech API option instead.');
            }
        });

        // Update model status indicator  
        function updateModelStatus(model) {
            modelBadge.className = 'model-badge';
            
            switch(model) {
                case 'webspeech':
                    modelBadge.classList.add('web-speech');
                    modelBadge.textContent = 'Web Speech API';
                    break;
                case 'local':
                    modelBadge.classList.add('vosk-model');
                    modelBadge.textContent = 'Local Model';
                    break;
                default:
                    modelBadge.classList.add('no-model');
                    modelBadge.textContent = 'Not Selected';
            }
        }
        
        /**
         * Properly formats the braille array for display exactly as it appears in the CSV
         * @param {Array|Array[]} array - The array data from the translator
         * @return {string} The formatted array string
         */
        function formatBrailleArrayForDisplay(array) {
            // For nested arrays (contractions)
            if (Array.isArray(array[0])) {
                return '{{' + array.map(subArray => {
                    return subArray.join(',');
                }).join('},{') + '}}';
            } 
            // For single character arrays
            else {
                return '{' + array.join(',') + '}';
            }
        }

        /**
         * Formats the language display with proper capitalization and handling of "Both"
         * @param {string} language - The language string from the database
         * @return {string} Properly formatted language display
         */
        function formatLanguageDisplay(language) {
            if (language === 'Both') {
                return 'Universal (UEB & Philippine)';
            } else {
                // Proper capitalization
                return language.charAt(0).toUpperCase() + language.slice(1);
            }
        }

        // Function to process speech results for Braille matching
        function processSpeechForBraille(text) {
            if (!brailleTranslator.isDatabaseLoaded()) {
                console.warn('Braille database not loaded yet');
                return;
            }
            
            const result = brailleTranslator.processText(text);
            
            if (result) {
                // We found a match!
                noMatchInfo.classList.add('hidden');
                brailleResult.classList.remove('hidden');
                
                // Update UI with matched word and braille symbol
                matchedWordElement.textContent = result.word;
                brailleSymbolElement.textContent = result.braille;
                
                // Format and display the language properly
                brailleLanguageElement.textContent = formatLanguageDisplay(result.language);
                
                // Debug the raw array content to verify what we're receiving
                console.log('Raw braille array for ' + result.word + ':', result.array);
                
                // Format the array display exactly as in the CSV file
                const formattedArray = formatBrailleArrayForDisplay(result.array);
                console.log('Formatted array:', formattedArray);
                
                // Display the formatted array
                brailleArrayElement.textContent = formattedArray;
            } else {
                // No match found
                brailleResult.classList.add('hidden');
                noMatchInfo.classList.remove('hidden');
            }
        }
        
        // Make sure the speech recognition object is available before setting up event handlers
        if (typeof speechRecognition !== 'undefined') {
            // Set up event handlers for our speech recognition service
            speechRecognition.on('start', () => {
                console.log('Speech recognition started');
                setRecordingState(true);
            });
            
            speechRecognition.on('end', () => {
                console.log('Speech recognition ended');
                setRecordingState(false);
            });
            
            speechRecognition.on('result', (text) => {
                console.log('Speech recognition final result:', text);
                finalTextElement.textContent += text + ' ';
                
                // Process the new text for Braille matching
                processSpeechForBraille(text);
            });
            
            speechRecognition.on('partialresult', (text) => {
                console.log('Speech recognition partial result:', text);
                interimTextElement.textContent = text;
            });
            
            speechRecognition.on('error', (error) => {
                console.error('Speech recognition error:', error);
                setRecordingState(false);
                alert(`Speech recognition error: ${error}`);
            });
        }
        
        // Function to start speech recognition
        startSpeechBtn.addEventListener('click', async () => {
            if (recognitionActive) return;
            
            // Clear previous text when starting new session
            interimTextElement.textContent = '';
            
            const selectedMethod = speechMethodSelect.value;
            
            try {
                console.log(`Starting speech recognition with method: ${selectedMethod}`);
                
                if (selectedMethod === 'local') {
                    // Check if the model badge indicates the model is loaded
                    if (modelBadge.textContent !== 'Local Model') {
                        alert('Please load the local model first by clicking the "Load Local Model" button.');
                        return;
                    }
                }
                
                await speechRecognition.start(selectedMethod);
                console.log('Speech recognition start method called');
            } catch (error) {
                console.error('Failed to start recognition:', error);
                alert(`Failed to start recognition: ${error.message}`);
            }
        });
        
        // Function to stop speech recognition
        stopSpeechBtn.addEventListener('click', () => {
            if (recognitionActive && speechRecognition) {
                console.log('Stopping speech recognition');
                speechRecognition.stop();
            }
        });
        
        // Helper function to update UI for recording state
        function setRecordingState(isRecording) {
            console.log(`Setting recording state: ${isRecording}`);
            recognitionActive = isRecording;
            
            // Update button states
            startSpeechBtn.disabled = isRecording;
            stopSpeechBtn.disabled = !isRecording;
            
            // Update recording indicator
            if (isRecording) {
                recordingIndicator.className = 'recording-on';
                recordingIndicator.textContent = '● Recording';
            } else {
                recordingIndicator.className = 'recording-off';
                recordingIndicator.textContent = '● Recording';
            }
            
            // Clear interim text if stopping
            if (!isRecording) {
                interimTextElement.textContent = '';
            }
        }

        // Add debugging helper to check if the speech recognition module is working
        console.log('Speech recognition module status:', {
            defined: typeof speechRecognition !== 'undefined',
            supported: typeof speechRecognition !== 'undefined' ? speechRecognition.isSupported() : false,
            webSpeech: typeof speechRecognition !== 'undefined' ? speechRecognition.webSpeechRecognition : false
        });
    </script>
    <script>
        // Initialize variables
        let deferredPrompt;
        const installButton = document.getElementById('install-button');
        const statusDiv = document.getElementById('connection-status');
        const lastUpdatedSpan = document.getElementById('last-updated');
        const dynamicContent = document.getElementById('dynamic-content');
        const refreshButton = document.getElementById('refresh-button');
        
        // Set the last updated time with local data
        lastUpdatedSpan.textContent = new Date().toLocaleString();
        
        // Check if the app is online and update the UI
        function updateOnlineStatus() {
            const isOnline = navigator.onLine;
            statusDiv.textContent = isOnline ? 'You are online.' : 'You are offline. Using cached content.';
            statusDiv.className = isOnline ? 'status online' : 'status offline';
        }
        
        // Add event listeners for online/offline events
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        updateOnlineStatus(); // Initial check
        
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(reg => {
                        console.log('Service worker registered!', reg);
                    })
                    .catch(err => {
                        console.log('Service worker registration failed:', err);
                    });
            });
        }
        
        // Handle app installation
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show the install button
            installButton.style.display = 'block';
        });
        
        installButton.addEventListener('click', () => {
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                });
            }
        });
        
        // Fetch cached data information
        async function checkCacheContents() {
            dynamicContent.innerHTML = '<p>Checking cache contents...</p>';
            
            try {
                // Check if we can access caches
                if (!('caches' in window)) {
                    dynamicContent.innerHTML = '<p class="error">Cache API not available in this browser.</p>';
                    return;
                }
                
                // Get all cache keys
                const cacheKeys = await caches.keys();
                
                if (cacheKeys.length === 0) {
                    dynamicContent.innerHTML = '<p>No caches found.</p>';
                    return;
                }
                
                let cacheContentsHTML = '<div class="cache-summary">';
                cacheContentsHTML += `<p><strong>${cacheKeys.length}</strong> cache(s) found</p>`;
                cacheContentsHTML += '</div>';
                
                // Process each cache
                for (const cacheName of cacheKeys) {
                    const cache = await caches.open(cacheName);
                    const requests = await cache.keys();
                    const requestUrls = requests.map(request => request.url);
                    
                    cacheContentsHTML += `<div class="cache-details">
                        <h3>Cache: ${cacheName}</h3>
                        <p><strong>${requestUrls.length}</strong> item(s) cached</p>
                        <details>
                            <summary>Show cached items</summary>
                            <ul class="cache-items">`;
                    
                    // Group items by type
                    const groupedItems = {
                        html: [],
                        css: [],
                        js: [],
                        images: [],
                        models: [],
                        other: []
                    };
                    
                    requestUrls.forEach(url => {
                        const path = new URL(url).pathname;
                        if (path.endsWith('.html')) {
                            groupedItems.html.push(url);
                        } else if (path.endsWith('.css')) {
                            groupedItems.css.push(url);
                        } else if (path.endsWith('.js')) {
                            groupedItems.js.push(url);
                        } else if (/\.(jpe?g|png|gif|svg|webp|ico)$/i.test(path)) {
                            groupedItems.images.push(url);
                        } else if (path.includes('/models/') || path.includes('vosk-model')) {
                            groupedItems.models.push(url);
                        } else {
                            groupedItems.other.push(url);
                        }
                    });
                    
                    // Add collapsible sections for each type
                    if (groupedItems.html.length) {
                        cacheContentsHTML += `<li><details>
                            <summary>HTML Files (${groupedItems.html.length})</summary>
                            <ul>${groupedItems.html.map(url => `<li>${displayUrl(url)}</li>`).join('')}</ul>
                        </details></li>`;
                    }
                    
                    if (groupedItems.css.length) {
                        cacheContentsHTML += `<li><details>
                            <summary>CSS Files (${groupedItems.css.length})</summary>
                            <ul>${groupedItems.css.map(url => `<li>${displayUrl(url)}</li>`).join('')}</ul>
                        </details></li>`;
                    }
                    
                    if (groupedItems.js.length) {
                        cacheContentsHTML += `<li><details>
                            <summary>JavaScript Files (${groupedItems.js.length})</summary>
                            <ul>${groupedItems.js.map(url => `<li>${displayUrl(url)}</li>`).join('')}</ul>
                        </details></li>`;
                    }
                    
                    if (groupedItems.images.length) {
                        cacheContentsHTML += `<li><details>
                            <summary>Images (${groupedItems.images.length})</summary>
                            <ul>${groupedItems.images.map(url => `<li>${displayUrl(url)}</li>`).join('')}</ul>
                        </details></li>`;
                    }
                    
                    if (groupedItems.models.length) {
                        cacheContentsHTML += `<li><details>
                            <summary>Speech Models (${groupedItems.models.length})</summary>
                            <ul>${groupedItems.models.map(url => `<li>${displayUrl(url)}</li>`).join('')}</ul>
                        </details></li>`;
                    }
                    
                    if (groupedItems.other.length) {
                        cacheContentsHTML += `<li><details>
                            <summary>Other Files (${groupedItems.other.length})</summary>
                            <ul>${groupedItems.other.map(url => `<li>${displayUrl(url)}</li>`).join('')}</ul>
                        </details></li>`;
                    }
                    
                    cacheContentsHTML += `</ul></details></div>`;
                }
                
                // Check for IndexedDB models
                cacheContentsHTML += '<div class="indexeddb-details">';
                cacheContentsHTML += '<h3>IndexedDB Models</h3>';
                
                try {
                    if ('speechRecognition' in window && typeof speechRecognition.isModelAvailableOffline === 'function') {
                        const modelAvailable = await speechRecognition.isModelAvailableOffline();
                        if (modelAvailable) {
                            cacheContentsHTML += '<p class="success">✓ Local speech model found in IndexedDB</p>';
                        } else {
                            cacheContentsHTML += '<p class="warning">No local speech models in IndexedDB</p>';
                        }
                    } else {
                        cacheContentsHTML += '<p class="warning">Cannot check IndexedDB speech models</p>';
                    }
                } catch (err) {
                    cacheContentsHTML += `<p class="error">Error checking IndexedDB: ${err.message}</p>`;
                }
                
                cacheContentsHTML += '</div>';
                
                // Update the timestamp
                cacheContentsHTML += `<p class="cache-timestamp">Last checked: ${new Date().toLocaleString()}</p>`;
                
                dynamicContent.innerHTML = cacheContentsHTML;
                
            } catch (error) {
                console.error('Error checking cache:', error);
                dynamicContent.innerHTML = `<p class="error">Error checking cache: ${error.message}</p>`;
            }
        }
        
        // Helper function to display URLs in a cleaner format
        function displayUrl(url) {
            // Extract just the pathname from the URL
            const urlObj = new URL(url);
            let path = urlObj.pathname;
            
            // If it's from our own origin, just show the path
            if (urlObj.origin === location.origin) {
                return path;
            }
            
            // For external URLs, show a simplified version
            return `${urlObj.hostname}${path}`;
        }
        
        // Initial cache check
        checkCacheContents();
        
        // Refresh button handler
        refreshButton.addEventListener('click', () => {
            checkCacheContents();
        });
    </script>
</body>
</html>
